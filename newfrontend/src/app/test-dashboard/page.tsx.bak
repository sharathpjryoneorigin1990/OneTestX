'use client';

import React, { useState, useEffect, useCallback, useMemo, FC } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { NewNavbar } from "@/components/layout/NewNavbar";
import { Button } from '@/components/ui/Button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card';
import { Badge } from '@/components/ui/Badge';
import { motion } from 'framer-motion';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';
import { useToast } from '@/components/ui/ToastContext';
import { FileText, CheckCircle2, XCircle, BarChart2, RefreshCw } from 'lucide-react';

// Helper functions
const delay = (ms: number): Promise<void> => new Promise(resolve => setTimeout(resolve, ms));

const formatPath = (path: string): string => {
  return path.replace(/^\//, '').replace(/\//g, ' › ');
};

const extractTagsFromPath = (filePath: string): string[] => {
  if (!filePath) return [];
  
  const tags = new Set<string>();
  const pathParts = filePath.split('/');
  
  // Extract potential tags from path parts
  pathParts.forEach(part => {
    if (part.startsWith('@')) {
      tags.add(part);
    }
    
    // Extract words that might be tags
    const words = part.split(/[\s\-\._]+/);
    words.forEach(word => {
      if (word.startsWith('@')) {
        tags.add(word);
      }
    });
  });
  
  return Array.from(tags);
};

// Button and badge variant helpers
const getButtonVariant = (isActive: boolean): 'outline' | 'primary' | 'secondary' | 'ghost' | 'neon' => {
  return isActive ? 'primary' : 'outline';
};

const getBadgeVariant = (status: TestStatus | undefined): 'default' | 'error' | 'success' | 'warning' | 'info' => {
  switch (status) {
    case 'passed':
      return 'success';
    case 'failed':
    case 'error':
      return 'error';
    case 'running':
      return 'info';
    case 'pending':
    case 'skipped':
      return 'warning';
    default:
      return 'default';
  }
};

// Remove duplicate declarations by ensuring these functions are only defined once

// Define interfaces for our test data
interface TestCase {
  name: string;
  group: string | null;
  line: number;
}

type TestStatus = 'passed' | 'failed' | 'running' | 'pending' | 'skipped' | 'error';

interface TestRun {
  status: TestStatus;
  duration: string;
  timestamp: string;
  output?: string[];
  error?: string;
  coverage?: number;
}

export interface TestFile {
  id: string;
  name: string;
  path: string;
  category: string;
  tags: string[];
  testCases: TestCase[];
  lastRun?: TestRun;
}

interface TestStats {
  totalTests: number;
  passed: number;
  failed: number;
  running: number;
  pending: number;
  coverage: number;
}

type ToastType = 'default' | 'error' | 'success';

interface ToastItem {
  id: string;
  title: string;
  message: string;
  type?: ToastType;
  duration?: number;
}

const TestDashboardPage: FC = (): React.ReactNode => {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [toasts, setToasts] = useState<ToastItem[]>([]);
  
  // State for test files and UI
  const [testFiles, setTestFiles] = useState<TestFile[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [expandedTest, setExpandedTest] = useState<string | null>(null);
  const [runningTests, setRunningTests] = useState<string[]>([]);
  const [testLogs, setTestLogs] = useState<Record<string, string[]>>({});
  const [error, setError] = useState<string | null>(null);
  
  // Stats for the dashboard
  const [stats, setStats] = useState<TestStats>({
    totalTests: 0,
    passed: 0,
    failed: 0,
    running: 0,
    pending: 0,
    coverage: 0,
  });
  
  // Show toast notification
  const showToast = useCallback(({ title, message, type = 'default', duration = 5000 }: Omit<ToastItem, 'id'>) => {
    const id = Math.random().toString(36).substr(2, 9);
    setToasts(prev => [...prev, { id, title, message, type, duration }]);
    
    if (duration > 0) {
      setTimeout(() => {
        setToasts(prev => prev.filter(t => t.id !== id));
      }, duration);
    }
  }, []);
  
  // Update test statistics
  const updateStats = useCallback((files: TestFile[]) => {
    const newStats: TestStats = {
      totalTests: files.length,
      passed: 0,
      failed: 0,
      running: 0,
      pending: 0,
      coverage: 0
    };
    
    files.forEach(file => {
      if (file.lastRun) {
        switch (file.lastRun.status) {
          case 'passed':
            newStats.passed++;
            break;
          case 'failed':
          case 'error':
          case 'skipped':
            newStats.failed++;
            break;
          case 'running':
            newStats.running++;
            break;
          case 'pending':
            newStats.pending++;
            break;
        }
      } else {
        newStats.pending++;
      }
    });
    
    // Calculate coverage if available
    const filesWithCoverage = files.filter(f => f.lastRun?.coverage !== undefined);
    if (filesWithCoverage.length > 0) {
      const totalCoverage = filesWithCoverage.reduce((sum, file) => {
        return sum + (file.lastRun?.coverage || 0);
      }, 0);
      newStats.coverage = Math.round((totalCoverage / filesWithCoverage.length) * 100);
    }
    
    setStats(newStats);
  }, []);
  
  // Load test files from the API
  const loadTestFiles = useCallback(async (): Promise<TestFile[]> => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/tests');
      
      if (!response.ok) {
        throw new Error(`Failed to load test files: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // Transform the API response to match our TestFile interface
      const transformedFiles: TestFile[] = data.map((testFile: any) => {
        // Ensure status is a valid TestStatus
        const status: TestStatus = ['passed', 'failed', 'running', 'pending', 'skipped', 'error'].includes(testFile.lastRun?.status)
          ? testFile.lastRun.status as TestStatus
          : 'pending';
          
        return {
          id: testFile.id || testFile.path,
          name: testFile.name || testFile.path.split('/').pop() || 'Unnamed Test',
          path: testFile.path,
          category: testFile.category || 'uncategorized',
          tags: Array.isArray(testFile.tags) ? testFile.tags : extractTagsFromPath(testFile.path),
          testCases: Array.isArray(testFile.testCases) ? testFile.testCases : [],
          lastRun: testFile.lastRun ? {
            status,
            duration: testFile.lastRun.duration || '0s',
            timestamp: testFile.lastRun.timestamp || new Date().toISOString(),
            ...(testFile.lastRun.output && { output: testFile.lastRun.output }),
            ...(testFile.lastRun.error && { error: testFile.lastRun.error }),
            ...(testFile.lastRun.coverage && { coverage: testFile.lastRun.coverage })
          } : undefined
        };
      });
      
      // Update stats based on the loaded files
      updateStats(transformedFiles);
      
      return transformedFiles;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load test files';
      setError(errorMessage);
      showToast({
        title: 'Error',
        message: errorMessage,
        type: 'error'
      });
      return [];
    } finally {
      setLoading(false);
    }
  }, [showToast, updateStats]);
  
  // Handle running a test
  const handleRunTest = useCallback(async (testId: string) => {
    try {
      setRunningTests(prev => [...prev, testId]);
      
      // Simulate test run
      await delay(2000);
      
      // Update test status with a random result for demonstration
      const testResult: TestStatus = Math.random() > 0.3 ? 'passed' : 'failed';
      
      setTestFiles(prevFiles => 
        prevFiles.map(file => 
          file.id === testId 
            ? { 
                ...file, 
                lastRun: { 
                  status: testResult,
                  duration: '1.2s',
                  timestamp: new Date().toISOString(),
                  coverage: testResult === 'passed' ? Math.floor(Math.random() * 100) : 0
                } 
              } 
            : file
        )
      );
      
      // Update logs
      setTestLogs(prevLogs => ({
        ...prevLogs,
        [testId]: [
          ...(prevLogs[testId] || []),
          `Test ${testId} ${testResult} at ${new Date().toISOString()}`
        ]
      }));
      
      showToast({
        title: 'Test Completed',
        message: `Test ${testId} ${testResult}`,
        type: testResult === 'passed' ? 'success' : 'error'
      });
      
      // Refresh test files to update stats
      const updatedFiles = await loadTestFiles();
      updateStats(updatedFiles);
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to run test';
      showToast({
        title: 'Error',
        message: `Failed to run test: ${errorMessage}`,
        type: 'error'
      });
    } finally {
      setRunningTests(prev => prev.filter(id => id !== testId));
    }
  }, [loadTestFiles, showToast, updateStats]);
  
  // Handle toggling a tag filter
  const handleTagToggle = useCallback((tag: string) => {
    setSelectedTags(prev => 
      prev.includes(tag) 
        ? prev.filter(t => t !== tag) 
        : [...prev, tag]
    );
  }, []);
  
  // Handle clearing all filters
  const handleClearFilters = useCallback(() => {
    setSelectedCategory(null);
    setSelectedTags([]);
    setSearchQuery('');
  }, []);
  
  // Handle search input change
  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  }, []);
  
  // Handle category change
  const handleCategoryChange = useCallback((category: string | null) => {
    setSelectedCategory(category === selectedCategory ? null : category);
  }, [selectedCategory]);
  
  // Toggle expanded test
  const handleToggleExpand = useCallback((testId: string) => {
    setExpandedTest(prev => prev === testId ? null : testId);
  }, []);
  
  // Load test files on mount
  useEffect(() => {
    const loadInitialData = async () => {
      const files = await loadTestFiles();
      setTestFiles(files);
    };
    
    loadInitialData();
  }, [loadTestFiles]);
  
  // Get all unique categories and tags for filtering
  const { categories, allTags } = useMemo(() => {
    const cats = new Set<string>();
    const tags = new Set<string>();
    
    testFiles.forEach(file => {
      if (file.category) cats.add(file.category);
      file.tags.forEach(tag => tags.add(tag));
    });
    
    return {
      categories: Array.from(cats).sort(),
      allTags: Array.from(tags).sort()
    };
  }, [testFiles]);
  
  // Filter test files based on search query and filters
  const filteredTestFiles = useMemo(() => {
    return testFiles.filter(file => {
      // Filter by search query
      const matchesSearch = !searchQuery || 
        file.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        file.path.toLowerCase().includes(searchQuery.toLowerCase()) ||
        file.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()));
      
      // Filter by category
      const matchesCategory = !selectedCategory || 
        file.category === selectedCategory || 
        file.tags.includes(selectedCategory);
      
      // Filter by tags (all selected tags must be present)
      const matchesTags = selectedTags.length === 0 || 
        selectedTags.every(tag => file.tags.includes(tag));
      
      return matchesSearch && matchesCategory && matchesTags;
    });
  }, [testFiles, searchQuery, selectedCategory, selectedTags]);
  
  // Update stats when test files change
  useEffect(() => {
    updateStats(testFiles);
  }, [testFiles, updateStats]);
  
  // Render the component
  return (
    <div className="min-h-screen bg-gray-50">
      <NewNavbar />
      
      <main className="container mx-auto px-4 py-8">
        {/* Header */}
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-gray-900 mb-2">Test Dashboard</h1>
          <p className="text-gray-600">Manage and run your test suites</p>
        </div>
        
        {/* Stats Cards */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-gray-500">Total Tests</CardTitle>
              <FileText className="h-4 w-4 text-gray-400" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold">{stats.totalTests}</div>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-green-600">Passed</CardTitle>
              <CheckCircle2 className="h-4 w-4 text-green-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-green-600">{stats.passed}</div>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-red-600">Failed</CardTitle>
              <XCircle className="h-4 w-4 text-red-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-red-600">{stats.failed}</div>
            </CardContent>
          </Card>
          
          <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="text-sm font-medium text-blue-600">Coverage</CardTitle>
              <BarChart2 className="h-4 w-4 text-blue-600" />
            </CardHeader>
            <CardContent>
              <div className="text-2xl font-bold text-blue-600">{stats.coverage}%</div>
            </CardContent>
          </Card>
        </div>
        
        {/* Test Files Section */}
        <div className="bg-white rounded-lg shadow overflow-hidden">
          <div className="p-6">
            <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
              <div className="w-full sm:w-auto">
                <input
                  type="text"
                  placeholder="Search tests..."
                  className="w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  value={searchQuery}
                  onChange={handleSearchChange}
                />
              </div>
              <div className="flex gap-2 flex-wrap">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleClearFilters}
                  disabled={!selectedCategory && selectedTags.length === 0}
                >
                  Clear Filters
                </Button>
                <Button
                  variant="default"
                  size="sm"
                  onClick={() => loadTestFiles()}
                  disabled={loading}
                >
                  <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
                  Refresh
                </Button>
              </div>
            </div>
            
            {/* Category and Tag Filters */}
            <div className="mb-6">
              <div className="mb-4">
                <h3 className="text-sm font-medium text-gray-700 mb-2">Categories</h3>
                <div className="flex flex-wrap gap-2">
                  <Button
                    variant={!selectedCategory ? 'primary' : 'outline' as const}
                    size="sm"
                    onClick={() => handleCategoryChange(null)}
                  >
                    All
                  </Button>
                  {categories.map(category => (
                    <Button
                      key={category}
                      variant={selectedCategory === category ? 'primary' : 'outline' as const}
                      variant={selectedCategory === category ? 'primary' : 'outline'}
                      variant={getButtonVariant(selectedCategory === category)}
                      size="sm"
                      onClick={() => handleCategoryChange(category)}
                    >
                      {category}
                    </Button>
                  ))}
                </div>
              </div>
              
              <div>
                <h3 className="text-sm font-medium text-gray-700 mb-2">Tags</h3>
                <div className="flex flex-wrap gap-2">
                  {allTags.map(tag => (
                    <Button
                      key={tag}
                      variant={getButtonVariant(selectedTags.includes(tag))}
                      size="sm"
                      onClick={() => handleTagToggle(tag)}
                    >
                      {tag}
                    </Button>
                  ))}
                </div>
              </div>
            </div>
            
            {/* Loading State */}
            {loading ? (
              <div className="flex justify-center items-center py-12">
                <LoadingSpinner size="lg" />
                <span className="ml-2">Loading test files...</span>
              </div>
            ) : error ? (
              <div className="text-center py-12">
                <p className="text-red-600 mb-4">Error loading test files: {error}</p>
                <Button
                  variant="primary"
                  onClick={loadTestFiles}
                >
                  <RefreshCw className="h-4 w-4 mr-2" />
                  Retry
                </Button>
              </div>
            ) : filteredTestFiles.length === 0 ? (
              <div className="text-center py-12">
                <p className="text-gray-500">No test files found matching your criteria.</p>
              </div>
            ) : (
              <div className="space-y-4">
                {filteredTestFiles.map(testFile => (
                  <div key={testFile.id} className="border rounded-lg overflow-hidden">
                    <div 
                      className="flex items-center justify-between p-4 bg-gray-50 cursor-pointer hover:bg-gray-100"
                      onClick={() => handleToggleExpand(testFile.id)}
                    >
                      <div className="flex-1 min-w-0">
                        <h3 className="font-medium text-gray-900 truncate">{testFile.name}</h3>
                        <p className="text-sm text-gray-500 truncate">{formatPath(testFile.path)}</p>
                      </div>
                      <div className="flex items-center space-x-2">
                        {testFile.lastRun?.status === 'passed' && (
                          <Badge variant="success">Passed</Badge>
                        )}
                        {testFile.lastRun?.status === 'failed' && (
                          <Badge variant="destructive">Failed</Badge>
                        )}
                        {testFile.lastRun?.status === 'running' && (
                          <Badge variant="outline" className="border-blue-300 text-blue-700 bg-blue-50">
                            Running...
                          </Badge>
                        )}
                        {!testFile.lastRun && (
                          <Badge variant="outline">Not Run</Badge>
                        )}
                        <Button
                          variant={getButtonVariant(runningTests.includes(testFile.id))}
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleRunTest(testFile.id);
                          }}
                          disabled={runningTests.includes(testFile.id)}
                        >
                          {runningTests.includes(testFile.id) ? (
                            <>
                              <LoadingSpinner size="sm" className="mr-2" />
                              Running...
                            </>
                          ) : (
                            'Run Test'
                          )}
                        </Button>
                      </div>
                    </div>
                    
                    {expandedTest === testFile.id && (
                      <div className="p-4 border-t bg-white">
                        <div className="mb-4">
                          <h4 className="font-medium text-gray-700 mb-2">Test Cases ({testFile.testCases.length})</h4>
                          <div className="space-y-2">
                            {testFile.testCases.length > 0 ? (
                              testFile.testCases.map((testCase, idx) => (
                                <div key={`${testFile.id}-${idx}`} className="flex items-center">
                                  <div className="w-2 h-2 rounded-full bg-green-500 mr-2"></div>
                                  <span className="text-sm text-gray-700">{testCase.name}</span>
                                </div>
                              ))
                            ) : (
                              <p className="text-sm text-gray-500">No test cases found.</p>
                            )}
                          </div>
                        </div>
                        
                        {testFile.lastRun && (
                          <div className="mt-4 pt-4 border-t">
                            <h4 className="font-medium text-gray-700 mb-2">Last Run</h4>
                            <div className="grid grid-cols-2 gap-4 text-sm">
                              <div>
                                <p className="text-gray-500">Status</p>
                                <p className="capitalize">{testFile.lastRun.status}</p>
                              </div>
                              <div>
                                <p className="text-gray-500">Duration</p>
                                <p>{testFile.lastRun.duration}</p>
                              </div>
                              <div>
                                <p className="text-gray-500">Timestamp</p>
                                <p>{new Date(testFile.lastRun.timestamp).toLocaleString()}</p>
                              </div>
                              {testFile.lastRun.coverage !== undefined && (
                                <div>
                                  <p className="text-gray-500">Coverage</p>
                                  <p>{testFile.lastRun.coverage}%</p>
                                </div>
                              )}
                            </div>
                            
                            {testFile.lastRun.output && testFile.lastRun.output.length > 0 && (
                              <div className="mt-4">
                                <h5 className="text-sm font-medium text-gray-700 mb-2">Output</h5>
                                <div className="bg-gray-50 p-3 rounded-md text-sm font-mono overflow-x-auto">
                                  {testFile.lastRun.output.map((line, i) => (
                                    <div key={i} className="text-gray-700">{line}</div>
                                  ))}
                                </div>
                              </div>
                            )}
                            
                            {testFile.lastRun.error && (
                              <div className="mt-4">
                                <h5 className="text-sm font-medium text-red-700 mb-2">Error</h5>
                                <div className="bg-red-50 p-3 rounded-md text-sm text-red-700 font-mono">
                                  {testFile.lastRun.error}
                                </div>
                              </div>
                            )}
                          </div>
                        )}
                        
                        {testLogs[testFile.id] && testLogs[testFile.id].length > 0 && (
                          <div className="mt-4 pt-4 border-t">
                            <h4 className="font-medium text-gray-700 mb-2">Logs</h4>
                            <div className="bg-gray-50 p-3 rounded-md text-sm font-mono max-h-40 overflow-y-auto">
                              {testLogs[testFile.id].map((log, i) => (
                                <div key={i} className="text-gray-700">{log}</div>
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </main>
      
      {/* Toast Notifications */}
      <div className="fixed bottom-4 right-4 space-y-2 z-50">
        {toasts.map(toast => (
          <motion.div
            key={toast.id}
            initial={{ opacity: 0, y: 50, scale: 0.3 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, scale: 0.5, transition: { duration: 0.2 } }}
            className={`p-4 rounded-md shadow-lg ${
              toast.type === 'error' 
                ? 'bg-red-100 border border-red-200 text-red-700' 
                : toast.type === 'success' 
                ? 'bg-green-100 border border-green-200 text-green-700'
                : 'bg-white border border-gray-200 text-gray-700'
            }`}
          >
            <div className="font-medium">{toast.title}</div>
            <div className="text-sm">{toast.message}</div>
          </motion.div>
        ))}
  const router = useRouter();
  const searchParams = useSearchParams();
  const [toasts, setToasts] = useState<ToastItem[]>([]);
  
  // State for test files and UI
  const [testFiles, setTestFiles] = useState<TestFile[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [expandedTest, setExpandedTest] = useState<string | null>(null);
  const [runningTests, setRunningTests] = useState<string[]>([]);
  const [testLogs, setTestLogs] = useState<Record<string, string[]>>({});
  const [error, setError] = useState<string | null>(null);
  
  // Stats for the dashboard
  const [stats, setStats] = useState<TestStats>({
    totalTests: 0,
    passed: 0,
    failed: 0,
    running: 0,
    pending: 0,
    coverage: 0,
  });
  
  // Show toast notification
  const showToast = useCallback(({ title, message, type = 'default', duration = 5000 }: Omit<ToastItem, 'id'>) => {
    const id = Math.random().toString(36).substr(2, 9);
    setToasts(prev => [...prev, { id, title, message, type, duration }]);
    
    if (duration > 0) {
      setTimeout(() => {
        setToasts(prev => prev.filter(t => t.id !== id));
      }, duration);
    }
  }, []);
  
  // Update test statistics
  const updateStats = useCallback((files: TestFile[]) => {
    const newStats: TestStats = {
      totalTests: files.length,
      passed: 0,
      failed: 0,
      running: 0,
      pending: 0,
      coverage: 0
    };
    
    files.forEach(file => {
      if (file.lastRun) {
        switch (file.lastRun.status) {
          case 'passed':
            newStats.passed++;
            break;
          case 'failed':
          case 'error':
          case 'skipped':
            newStats.failed++;
            break;
          case 'running':
            newStats.running++;
            break;
          case 'pending':
            newStats.pending++;
            break;
        }
      } else {
        newStats.pending++;
      }
    });
    
    // Calculate coverage if available
    const filesWithCoverage = files.filter(f => f.lastRun?.coverage !== undefined);
    if (filesWithCoverage.length > 0) {
      const totalCoverage = filesWithCoverage.reduce((sum, file) => {
        return sum + (file.lastRun?.coverage || 0);
      }, 0);
      newStats.coverage = Math.round((totalCoverage / filesWithCoverage.length) * 100);
    }
    
    setStats(newStats);
  }, []);
  
  // Load test files from the API
  const loadTestFiles = useCallback(async (): Promise<TestFile[]> => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/tests');
      
      if (!response.ok) {
        throw new Error(`Failed to load test files: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // Transform the API response to match our TestFile interface
      const transformedFiles: TestFile[] = data.map((testFile: any) => {
        // Ensure status is a valid TestStatus
        const status: TestStatus = ['passed', 'failed', 'running', 'pending', 'skipped', 'error'].includes(testFile.lastRun?.status)
          ? testFile.lastRun.status as TestStatus
          : 'pending';
          
        return {
          id: testFile.id || testFile.path,
          name: testFile.name || testFile.path.split('/').pop() || 'Unnamed Test',
          path: testFile.path,
          category: testFile.category || 'uncategorized',
          tags: Array.isArray(testFile.tags) ? testFile.tags : extractTagsFromFile(testFile.path),
          testCases: Array.isArray(testFile.testCases) ? testFile.testCases : [],
          lastRun: testFile.lastRun ? {
            status,
            duration: testFile.lastRun.duration || '0s',
            timestamp: testFile.lastRun.timestamp || new Date().toISOString(),
            ...(testFile.lastRun.output && { output: testFile.lastRun.output }),
            ...(testFile.lastRun.error && { error: testFile.lastRun.error }),
            ...(testFile.lastRun.coverage && { coverage: testFile.lastRun.coverage })
          } : undefined
        };
      });
      
      // Update stats based on the loaded files
      updateStats(transformedFiles);
      
      return transformedFiles;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load test files';
      setError(errorMessage);
      showToast({
        title: 'Error',
        message: errorMessage,
        type: 'error'
      });
      return [];
    } finally {
      setLoading(false);
    }
  }, [showToast, updateStats]);
  
  // Handle running a test
  const handleRunTest = useCallback(async (testId: string) => {
    try {
      setRunningTests(prev => [...prev, testId]);
      
      // Simulate test run
      await delay(2000);
      
      // Update test status with a random result for demonstration
      const testResult: TestStatus = Math.random() > 0.3 ? 'passed' : 'failed';
      
      setTestFiles(prevFiles => 
        prevFiles.map(file => 
          file.id === testId 
            ? { 
                ...file, 
                lastRun: { 
                  status: testResult,
                  duration: '1.2s',
                  timestamp: new Date().toISOString(),
                  coverage: testResult === 'passed' ? Math.floor(Math.random() * 100) : 0
                } 
              } 
            : file
        )
      );
      
      // Update logs
      setTestLogs(prevLogs => ({
        ...prevLogs,
        [testId]: [
          ...(prevLogs[testId] || []),
          `Test ${testId} ${testResult} at ${new Date().toISOString()}`
        ]
      }));
      
      showToast({
        title: 'Test Completed',
        message: `Test ${testId} ${testResult}`,
        type: testResult === 'passed' ? 'success' : 'error'
      });
      
      // Refresh test files to update stats
      const updatedFiles = await loadTestFiles();
      updateStats(updatedFiles);
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to run test';
      showToast({
        title: 'Error',
        message: `Failed to run test: ${errorMessage}`,
        type: 'error'
      });
    } finally {
      setRunningTests(prev => prev.filter(id => id !== testId));
    }
  }, [loadTestFiles, showToast, updateStats]);
  
  // Handle toggling a tag filter
  const handleTagToggle = useCallback((tag: string) => {
    setSelectedTags(prev => 
      prev.includes(tag) 
        ? prev.filter(t => t !== tag) 
        : [...prev, tag]
    );
  }, []);
  
  // Handle clearing all filters
  const handleClearFilters = useCallback(() => {
    setSelectedCategory(null);
    setSelectedTags([]);
    setSearchQuery('');
  }, []);
  
  // Handle search input change
  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  }, []);
  
  // Handle category change
  const handleCategoryChange = useCallback((category: string | null) => {
    setSelectedCategory(category === selectedCategory ? null : category);
  }, [selectedCategory]);
  
  // Load test files on mount
  useEffect(() => {
    const loadInitialData = async () => {
      const files = await loadTestFiles();
      setTestFiles(files);
    };
    
    loadInitialData();
  }, [loadTestFiles]);
  
  // Get all unique categories and tags for filtering
  const { categories, allTags } = useMemo(() => {
    const cats = new Set<string>();
    const tags = new Set<string>();
    
    testFiles.forEach(file => {
      if (file.category) cats.add(file.category);
      file.tags.forEach(tag => tags.add(tag));
    });
    
    return {
      categories: Array.from(cats).sort(),
      allTags: Array.from(tags).sort()
    };
  }, [testFiles]);
  
  // Filter test files based on search query and filters
  const filteredTestFiles = useMemo(() => {
    return testFiles.filter(file => {
      // Filter by search query
      const matchesSearch = !searchQuery || 
        file.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        file.path.toLowerCase().includes(searchQuery.toLowerCase()) ||
        file.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()));
      
      // Filter by category
      const matchesCategory = !selectedCategory || 
        file.category === selectedCategory || 
        file.tags.includes(selectedCategory);
      
      // Filter by tags (all selected tags must be present)
      const matchesTags = selectedTags.length === 0 || 
        selectedTags.every(tag => file.tags.includes(tag));
      
      return matchesSearch && matchesCategory && matchesTags;
    });
  }, [testFiles, searchQuery, selectedCategory, selectedTags]);
  
  // Update stats when test files change
  useEffect(() => {
    updateStats(testFiles);
  }, [testFiles, updateStats]);
  
  // Format path for display
  const formatPath = useCallback((path: string): string => {
    return path.replace(/^\//, '').replace(/\//g, ' › ');
  }, []);
  
  // Extract tags from file path
  const extractTagsFromFile = useCallback((filePath: string): string[] => {
    if (!filePath) return [];
    
    const tags = new Set<string>();
    const pathParts = filePath.split('/');
    
    // Extract potential tags from path parts
    pathParts.forEach(part => {
      if (part.startsWith('@')) {
        tags.add(part);
      }
      
      // Extract words that might be tags
      const words = part.split(/[\s\-\._]+/);
      words.forEach(word => {
        if (word.startsWith('@')) {
          tags.add(word);
        }
      });
    });
    
    return Array.from(tags);
  }, []);
  
  // Load test files from the API
  const loadTestFiles = useCallback(async (): Promise<TestFile[]> => {
    try {
      setLoading(true);
      setError(null);
      
      // Build query parameters based on filters
      const params = new URLSearchParams();
      if (selectedCategory) params.append('category', selectedCategory);
      if (selectedTags.length > 0) params.append('tags', selectedTags.join(','));
      
      // Use the API route to fetch tests
      const response = await fetch(`/api/tests?${params.toString()}`, {
        headers: {
          'Accept': 'application/json',
          'Cache-Control': 'no-cache',
        },
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      console.log('API Response:', data);
      
      if (!data.tests || !Array.isArray(data.tests)) {
        throw new Error('Invalid test data format received from server');
      }
      
      // Transform the data to match our TestFile interface
      const transformedFiles: TestFile[] = data.tests.map((test: any) => {
        // Ensure test has required fields
        const testId = test.id || `test-${Math.random().toString(36).substr(2, 9)}`;
        const testName = test.name || 
          (typeof test.path === 'string' ? test.path.split('/').pop() : 'Unnamed Test');
        const testPath = test.path || 'unknown/path';
        const testCategory = test.category || 
          (typeof test.path === 'string' ? test.path.split('/')[0] : 'uncategorized');
        const testTags = Array.isArray(test.tags) ? test.tags : [];
      
      return transformedFiles;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load test files';
      setError(errorMessage);
      showToast({
        title: 'Error',
        message: errorMessage,
        type: 'error'
      });
      return [];
    } finally {
      setLoading(false);
  const updateStats = useCallback((files: TestFile[]) => {
    const newStats: TestStats = {
      totalTests: files.length,
      passed: 0,
      failed: 0,
      running: 0,
      pending: 0,
      coverage: 0,
    };

    files.forEach((file) => {
      if (file.lastRun) {
        switch (file.lastRun.status) {
          case 'passed':
            newStats.passed++;
            break;
          case 'failed':
            newStats.failed++;
            break;
          case 'running':
            newStats.running++;
            break;
          case 'pending':
            newStats.pending++;
            break;
          // Handle other statuses if needed
          case 'skipped':
          case 'error':
            newStats.failed++;
            break;
        }
      } else {
        newStats.pending++;
      }
    });

    // Calculate coverage if any test has coverage data
    const filesWithCoverage = files.filter((f) => f.lastRun?.coverage !== undefined);
    if (filesWithCoverage.length > 0) {
      const totalCoverage = filesWithCoverage.reduce((sum, file) => {
        return sum + (file.lastRun?.coverage || 0);
      }, 0);
      newStats.coverage = Math.round((totalCoverage / filesWithCoverage.length) * 100);
    }

    setStats(newStats);
  }, []);

  const handleRunTest = useCallback(async (testId: string) => {
    try {
      setRunningTests((prev) => [...prev, testId]);

      // Simulate test run
      await new Promise((resolve) => setTimeout(resolve, 2000));

      // Update test status
      setTestFiles((prevFiles) =>
        prevFiles.map((file) =>
          file.id === testId
            ? {
                ...file,
                lastRun: {
                  status: Math.random() > 0.3 ? 'passed' : 'failed',
                  duration: '1.2s',
                  timestamp: new Date().toISOString(),
                },
              }
            : file
        )
      );

      // Update stats
      const updatedFiles = testFiles.map((file) =>
        file.id === testId
          ? {
              ...file,
              lastRun: {
                status: Math.random() > 0.3 ? 'passed' : 'failed',
                duration: '1.2s',
                timestamp: new Date().toISOString(),
              },
            }
          : file
      );
      updateStats(updatedFiles);

      showToast({
        title: 'Test Completed',
        message: `Test ${testId} has finished running`,
        type: 'success',
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to run test';
      showToast({
        title: 'Error',
        message: errorMessage,
        type: 'error',
      });
    } finally {
      setRunningTests((prev) => prev.filter((id) => id !== testId));
    }
  }, [showToast, testFiles]);

  const loadTestFiles = useCallback(async (): Promise<TestFile[]> => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch('/api/tests');

      if (!response.ok) {
        throw new Error(`Failed to load test files: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();

      // Transform the API response to match our TestFile interface
      const transformedFiles: TestFile[] = data.map((testFile: any) => ({
        id: testFile.id || testFile.path,
        name: testFile.name || testFile.path.split('/').pop() || 'Unnamed Test',
        path: testFile.path,
        category: testFile.category || 'uncategorized',
        tags: Array.isArray(testFile.tags) ? testFile.tags : [],
        testCases: Array.isArray(testFile.testCases) ? testFile.testCases : [],
        lastRun: testFile.lastRun
          ? {
              status: testFile.lastRun.status,
              duration: testFile.lastRun.duration || '0s',
              timestamp: testFile.lastRun.timestamp || new Date().toISOString(),
              ...(testFile.lastRun.output && { output: testFile.lastRun.output }),
              ...(testFile.lastRun.error && { error: testFile.lastRun.error }),
            }
          : undefined,
      }));

      // Update stats based on the loaded files
      updateStats(transformedFiles);

      return transformedFiles;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load test files';
      setError(errorMessage);
      showToast({
        title: 'Error',
        message: errorMessage,
        type: 'error',
      });
      return [];
    } finally {
      setLoading(false);
    }
  }, [showToast, updateStats]);

  const handleTagToggle = useCallback((tag: string) => {
    setSelectedTags((prev) => (prev.includes(tag) ? prev.filter((t) => t !== tag) : [...prev, tag]));
  }, []);

  const handleClearFilters = useCallback(() => {
    setSelectedCategory(null);
    setSelectedTags([]);
    setSearchQuery('');
  }, []);

  const handleSearch = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
  }, []);

  const handleCategorySelect = useCallback((category: string | null) => {
    setSelectedCategory(category);
  }, []);

  const categories = useMemo(() => {
    const cats = new Set<string>();
    testFiles.forEach((file) => {
      if (file.category) cats.add(file.category);
      file.tags.forEach((tag) => cats.add(tag));
    });
    return Array.from(cats).sort();
  }, [testFiles]);

  const allTags = useMemo(() => {
    const tags = new Set<string>();
    testFiles.forEach((file) => {
      file.tags.forEach((tag) => tags.add(tag));
    });
    return Array.from(tags).sort();
  }, [testFiles]);

  const filteredTestFiles = useMemo(() => {
    return testFiles.filter((file) => {
      // Filter by search query
      const matchesSearch =
        !searchQuery ||
        file.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        file.path.toLowerCase().includes(searchQuery.toLowerCase()) ||
        file.tags.some((tag) => tag.toLowerCase().includes(searchQuery.toLowerCase()));

      // Filter by category
      const matchesCategory = !selectedCategory || file.category === selectedCategory;

      // Filter by tags
      const matchesTags = selectedTags.length === 0 || selectedTags.every((tag) => file.tags.includes(tag));

      return matchesSearch && matchesCategory && matchesTags;
    });
  }, [testFiles, searchQuery, selectedCategory, selectedTags]);

  useEffect(() => {
    loadTestFiles();
  }, [loadTestFiles]);

  return (
    <div className="flex flex-col min-h-screen bg-gray-50">
      <NewNavbar />

      <main className="flex-1 p-6">
        <div className="max-w-7xl mx-auto">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-2xl font-bold text-gray-900">Test Dashboard</h1>
            <div className="flex space-x-2">
              <Button variant="outline" onClick={() => loadTestFiles()} disabled={loading}>
                <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
                Refresh
              </Button>
            </div>
          </div>

          {/* Stats Cards */}
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
            <div className="bg-white p-4 rounded-lg shadow">
              <div className="flex items-center">
                <div className="p-3 rounded-full bg-gray-100 text-gray-600">
                  <FileText className="h-6 w-6" />
                </div>
                <div className="ml-4">
                  <p className="text-sm font-medium text-gray-500">Total Tests</p>
                  <p className="text-2xl font-semibold">{stats.totalTests}</p>
                </div>
              </div>
            </div>
            <div className="bg-white p-4 rounded-lg shadow">
              <div className="flex items-center">
                <div className="p-3 rounded-full bg-green-100 text-green-600">
                  <CheckCircle2 className="h-6 w-6" />
                </div>
                <div className="ml-4">
                  <p className="text-sm font-medium text-gray-500">Passed</p>
                  <p className="text-2xl font-semibold text-green-600">{stats.passed}</p>
                </div>
              </div>
            </div>
            <div className="bg-white p-4 rounded-lg shadow">
              <div className="flex items-center">
                <div className="p-3 rounded-full bg-red-100 text-red-600">
                  <XCircle className="h-6 w-6" />
                </div>
                <div className="ml-4">
                  <p className="text-sm font-medium text-gray-500">Failed</p>
                  <p className="text-2xl font-semibold text-red-600">{stats.failed}</p>
                </div>
              </div>
            </div>
            <div className="bg-white p-4 rounded-lg shadow">
              <div className="flex items-center">
                <div className="p-3 rounded-full bg-blue-100 text-blue-600">
                  <BarChart2 className="h-6 w-6" />
                </div>
                <div className="ml-4">
                  <p className="text-sm font-medium text-gray-500">Coverage</p>
                  <p className="text-2xl font-semibold text-blue-600">{stats.coverage}%</p>
                </div>
              </div>
            </div>
          </div>

          {/* Filters */}
          <div className="bg-white rounded-lg shadow p-4 mb-6">
            <div className="flex flex-col space-y-4 md:flex-row md:items-center md:space-y-0 md:space-x-4">
              <div className="flex-1">
                <input
                  type="text"
                  placeholder="Search tests..."
                  className="w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  value={searchQuery}
                  onChange={handleSearch}
                />
              </div>
              <div className="flex flex-wrap gap-2">
                <select
                  className="px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                  value={selectedCategory || ''}
                  onChange={(e) => handleCategorySelect(e.target.value || null)}
                >
                  <option value="">All Categories</option>
                  {categories.map((category) => (
                    <option key={category} value={category}>
                      {category}
                    </option>
                  ))}
                </select>
                <div className="flex flex-wrap gap-2">
                  {allTags.map((tag) => (
                    <button
                      key={tag}
                      className={`px-3 py-1 text-sm rounded-full ${
                        selectedTags.includes(tag)
                          ? 'bg-blue-100 text-blue-800 border border-blue-200'
                          : 'bg-gray-100 text-gray-700 border border-gray-200 hover:bg-gray-200'
                      }`}
                      onClick={() => handleTagToggle(tag)}
                    >
                      {tag}
                    </button>
                  ))}
                </div>
                {(selectedCategory || selectedTags.length > 0) && (
                  <button
                    className="px-3 py-1 text-sm text-gray-600 hover:text-gray-800"
                    onClick={handleClearFilters}
                  >
                    Clear filters
                  </button>
                )}
              </div>
            </div>
          </div>

          {/* Test Files */}
          <div className="bg-white rounded-lg shadow overflow-hidden">
            {loading ? (
              <div className="flex justify-center items-center p-12">
                <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500"></div>
              </div>
            ) : error ? (
              <div className="p-6 text-center text-red-600">
                <p>Error loading test files: {error}</p>
                <button
                  className="mt-2 px-4 py-2 bg-red-100 text-red-700 rounded-md hover:bg-red-200"
                  onClick={() => loadTestFiles()}
                >
                  Retry
                </button>
              </div>
            ) : (
              <TestFilesView
                testFiles={filteredTestFiles}
                onRunTest={handleRunTest}
                runningTests={runningTests}
                expandedTest={expandedTest}
                onToggleExpand={setExpandedTest}
                testLogs={testLogs}
              />
            )}
          </div>
        </div>
      </main>

      {/* Toast Notifications */}
      <div className="fixed bottom-4 right-4 space-y-2 z-50">
        {toasts.map((toast) => (
          <div
            key={toast.id}
            className={`px-6 py-4 rounded-md shadow-lg text-white ${
              toast.type === 'error' ? 'bg-red-500' : toast.type === 'success' ? 'bg-green-500' : 'bg-blue-500'
            }`}
          >
            <div className="font-medium">{toast.title}</div>
            <div className="text-sm opacity-90">{toast.message}</div>
          </div>
        ))}
      </div>
    </div>
  );
}
